sc
val pagecounts = sc.textFile("data/pagecounts")
pagecounts.take(10)
exit
sc
val pagecounts = sc.textFile("data/pagecounts")
 pagecounts.take(10)
exit

ec it
exit
exir
exit
import org.apache.hadoop.fs._
val path = new Path("file:/tmp/hive")
val lfs = FileSystem.get(path.toUri(), sc.hadoopConfiguration)
lfs.getFileStatus(path).getPermission()
exit
 exit
exit
sc.stop()
exit
sc
val textFile=sc.textFile("file:///Spark/README.md")
textFile.first
val textFile=sc.textFile("file:///readme.txt")
textFile.first
val textFile=sc.textFile("readme.txt")
textFile.first
val textFile=sc.textFile("file:///spark/readme.txt")
textFile.first
val textFile=sc.textFile("/spark/readme.txt")
textFile.first
val textFile=sc.textFile("readme.txt")
textFile.first
val textFile=sc.textFile("file:///readme.txt")
textFile.first
val textFile=sc.textFile("file://readme.txt")
textFile.first
val textFile=sc.textFile("file:///D:/git_work/spark/readme.txt")
textFile.first
def history = scala.io.Source.fromFile(System.getProperty("user.home") + "/.scala_history").foreach(print)
history
less ~/.scala_history
:save his.txt
:help
:history
:history /?
:history 100
:history 100 >his.txt
sc
:paste
  1  sc
  2  val pagecounts = sc.textFile("data/pagecounts")
  3  pagecounts.take(10)
  4  exit
  5  sc
  6  val pagecounts = sc.textFile("data/pagecounts")
  7   pagecounts.take(10)
  8  exit
  9  ?
 10  ec it
 11  exit
 12  exir
 13  exit
 14  import org.apache.hadoop.fs._
 15  val path = new Path("file:/tmp/hive")
 16  val lfs = FileSystem.get(path.toUri(), sc.hadoopConfiguration)
 17  lfs.getFileStatus(path).getPermission()
 18  exit
 19   exit
 20  exit
 21  sc.stop()
 22  exit
 23  sc
 24  val textFile=sc.textFile("file:///Spark/README.md")
 25  textFile.first
 26  val textFile=sc.textFile("file:///readme.txt")
 27  textFile.first
 28  val textFile=sc.textFile("readme.txt")
 29  textFile.first
 30  val textFile=sc.textFile("file:///spark/readme.txt")
 31  textFile.first
 32  val textFile=sc.textFile("/spark/readme.txt")
 33  textFile.first
 34  val textFile=sc.textFile("readme.txt")
 35  textFile.first
 36  val textFile=sc.textFile("file:///readme.txt")
 37  textFile.first
 38  val textFile=sc.textFile("file://readme.txt")
 39  textFile.first
 40  val textFile=sc.textFile("file:///D:/git_work/spark/readme.txt")
 41  textFile.first
 42  def history = scala.io.Source.fromFile(System.getProperty("user.home") + "/
.scala_history").foreach(print)
 43  history
 44  less ~/.scala_history
 45  :save his.txt
 46  :help
 47  :history
 48  :history /?
 49  :history 100
 50  :history 100 >his.txtafnk
fkjsdbkfjn
clear
cls
:clear
:help
:reset
exit
val textFile=sc.textFile("readme.txt")
sc
:reset
sc
:q
sc
val textFile=sc.textFile("readme.txt")
textFile.first
val tokenizedFileData=textFile.flatMap(line=>line.split(" "))
tokenizedFileData
val countPrep=tokenizedFileData.map(word=>(word,1))
val counts=countPrep.reduceByKeu((accumValue,newValue)=accumValue+newValue)
val counts=countPrep.reduceByKeu((accumValue,newValue)=>\accumValue+newValue)
val counts=countPrep.reduceByKey((accumValue,newValue)=>\accumValue+newValue)
val counts=countPrep.reduceByKey((accumValue,newValue)=>accumValue+newValue)
val sortedCounts=counts.sortBy(kvPair=>kvPair._2,false)
sortedCounts.saveAsTextFile("file:///D:/git_work/spark/ReadMeWordCount/")
tokenizedFileData.countByValue
:version
:help
:q
sc.parallelize
sc.parallelize(1 to 100)
res1.collect
:history
sc.parallelize(1 to 100,50)
res3.collect
sc.parallelize(1 to 100,5)
res5.collect
sc.range(1,100,5)
res7.collect
sc.range(1,100)
res9.collect
sc.range(1,100,10)
res11.collect
exit
:help
:implicits
1.plus(1)
case class IntExtensions(val:Int){}
case class IntExtensions(val:Int){ def plusI(op:Int)=val+op}
case class IntExtensions(val:Int){
case class IntExtensions(value:Int){ def plusI(op:Int)=value+op}
:Implicits
:Implicit
:implicits
IntExtensions(1).plus(1)
IntExtensions(1).plusI(1)
implicit def Intex(value:Int){}
implicit def Intex(value:Int){IntExtensions(value)}
:implicits
import scala.language.implicitConversions
implicit def Intex(value:Int){IntExtensions(value)}
:implicits
1.plus(1)
1.plusI(1)
implicit def inttoIntExtensions(value:Int){IntExtensions(value)}
1.plusI(1)
case class IntExtensions(val:Int){ def plus(op:Int)=val+op}
case class IntExtensions(value:Int){ def plus(op:Int)=val+op}
case class IntExtensions(value:Int){ def plus(op:Int)=value+op}
implicit def inttoIntExtensions(value:Int){IntExtensions(value)}
1.plus(1)
:implicits
sc.
sc.In
sc --help
sc -help
sc.year
sc.year(05/20/1985)
sc.year
:quit
import main._
wikiDocuments
import main._
main.Evaluator
res1.wikiDocuments
res1.main
res1.toString
import Main._
import main._
new Main
import main
.
_
import main._
:q
import main._
main
:q
i
import main._
import
main
;
:q
:
?"
:q
import main._
:q
import main._
import Main._
new Main()
:q
import main._
implort org.apache.hadoop.io._
import org.apache.hadoop.io._
"Hello World"
"Hello \n World"
"Hello \nWorld"
res0
res1
res3
res1+res3
2
"2"
res8+res7
2+3
:t
:t res10
:t res12
:t res7
:t res2
print("Hello world")
println("Hello world")
println("Hello\n world")
val x=3
x
x+3
x
x=x=5
x=x+5
var x=7
x=x+7
:t x
val a:Int=4
:t a
a=a+5
def a=45
:t a
a=6
print("here a is a method")
print(here a is a method)
print(a)
def func(x:Int)=x
func(2)
def func1(x:Int)=x*x
func1(2)
def func2(x:Int)=_
def func2(x:Int)=_*_
def func2(x:Int,y:Int)=_*_
def func2(x:Int,y:Int):Double=x*y
func2(4,5)
print(func2(4,5))
def squandAdd(x:Int,y:Int)=x*x+y*y
def squandAdd(x:Int,y:Int):Double=x*x+y*y
squandAdd
squandAdd()
squandAdd(4,5)
def squandAdd1(x:Int):Double=x*x+y*y
def squandAdd1(x:Int)=x*x+y*y
def squareThenAdd ( x:Int)  = x*x + y*y
:history
:history 500
println("tuples")
val tup=(4,5)
tup
tup._1
tup._2
tup.swap
tup.swap._1
tup.swap._2
tup.swap.toString
tup.swap.toString._1
tup.swap.toString.isEmpty
tup.swap.toString.lastIndexOf
tup.swap.toString.lastIndexOf(1)
tup.swap.toString.lastIndexOf(4)
tup.swap.toString.lastIndexOf(5)
tup.swap.toString.lastIndexOf("5")
tup.swap.toString.lastIndexOf("4")
tup.swap.toString.split(",")
tup.swap.toString.split(",").collect
.split(",").println
tup.swap.toString.split(",").print
val twoStrings = ("hello","world")
val threeDoubles = (3.14,11.29,1.5)
val intAndString = (7,"Lucky")
val mixedup = (1,"hello",1.16)
val (first,second) = twoInts
val (first,second) = twoStrings
first
second
val (numTimes,thingtoSay,price) = mixedup
def rangeAround(midPoint: Int,size:Int) = (midPoint - size,midPoint + size)
rangeAround(5,10)
rangeAround(21,3)
val (left,right) = rangeAround(21,3)
mixedup
print(mixedup._1)
print(mixedup._2)
print(mixedup._3)
val groceryList = List("apples","milk","butter")
val odds = List(11,3,5,7,9)
val multinomail = List(.2,.4,.15,.25)
val intsAndDoubles = List(1,1.5,2,2.5)
val today = List("December",20,2015)
val embedded = List(List(1,2,3),List(10,30,50),List(200,400),List(1000))
groceryList.length
odds.length
embedded.length
res55+res56
odds+embedded
(2,4,6,7).length
(2,4,6,7).toString.length
"Hi".length
5|3
5%3
5&3
5*3
5+3
5-3
5/3
5>3
5<3
5>=3
5<=3
5==3
5>>3
5<<3
5<<<3
5>>>3
5.3
(2) + (3)
2) .+ (3)
(2) .+ (3)
"portis".+("head")
val evens = List(2,3,6,8)
odds
val nums = odds ++ evens
odds.:+evens
odds++evens
val zeroToNine = 0 :: nums
zeroToNine.sorted
val zeroToNine = 4 :: nums
val zeroToNine1 = 0 :: zeroToNine
zeroToNine1.sorted
zeroToNine1.sorted.reverse
val fixed = List(1,2)
fixed = List(3,4)
var reassingable = List(5,6)
reassingable = List(7,8)
odds
odds(0)
odds(2)
odds(2-0)
odds(2-1)
odds(10)
zeroToNine
zeroToNine.slice(2,6)
val artis = "Srinu"
artis(3)
artis.slice(1,4)
artis.reverse
artis.sorted
odds
odds.sum
groceryList
odds.zip
groceryList
groceryList.mkString
groceryList.mkString(" ")
groceryList.mkString("\n")
odds.mkString("\n")
groceryList.contains("apple")
groceryList.contains("apples")
val odds = List(1,3,5,7,9)
odds.map(+1)
odds.map(1+)
odds
odds.map(1-)
odds.map(1*)
odds.map(5*)
odds.filter(4<)
odds.filter(5<)
odds.map(5<)
odds.foldLeft(10)(_+_)
odds.foldLeft()(_+_)
odds.foldLeft(1)(_+_)
odds.foldLeft(1)
odds.foldLeft(1)(_)
res125
odds.reduce(_+_)
odds.filter(6>).map(_.toString)
odds.filter(6>).map(_.toString).reduce(_+_)
odds.filter(6>).map(1+)
odds.filter(6>).map(1+).reduce(_+_)
odds
odds.filter(6>)
odds.filter(6<)
odds.filter(6<).mkString(",")
:HISTORY 800
:history 800
clear
cls
:help
val engToDeu = Map(("dog","Hund"),("cat","katze"),("rhinoceros","Nashorn"))
engToDeu("dog");
val engWord = List("dog","cat","rhinoceros");
val deuWords = List("Hund","katze","Nashorn")
engWord.indexOf("cat");
deuWords(engWord.indexOf("cat"));
engWord.zip(deuWords);
engWord.zip(deuWords).toMap
res141.toMap
engToDeu + "owl" -> "Eule";
engToDeu + ("owl" -> "Eule","hippopotamus" -> "Nilpferd");
engToDeu + "owl" -> "Eule";
res146
res146._1
engToDeu + ("owl" -> "Eule");
res146._2
res146._3
res146("owl")
res146("Eule")
val newEntries = Map(("hippopotamus","Nilpferd"),("owl","Eule"))
engToDeu
val expandedEngToDeu = engToDeu ++ newEntries;
engToDeu("dog")
engToDeu - "dog"
engToDeu + ("dog"->"nick")
engToDeu
engToDeu + ("dog"->"nick")
engToDeu("bird")
engToDeu.contains("bird");
engToDeu.contains("cat");
val wordsToTranslate = List("dog","bird","cat","armadillo")
wordsToTranslate.filter(x => engToDeu.contains(x))
wordsToTranslate.filter(x => engToDeu.contains(x)).map(x=>engToDeu(x))
res164.toMap
res164
res164.map(s=>(s,s.length))
res164.map(s=>(s,s.length)).toMap
val listtuple=List[(),(),(),()]
val listtuple=List[(1),(2),(3),(4)]
val listtuple=List((1),(2),(3),(4))
val listtuple=List((),(),(),())
val listtuple=List((1,4),(2,5),(3,7),(4,9))
listtuple
listtuple:Int
:t listtuple
listtuple::()
listtuple+()
listtuple++()
listtuple++(6,7)
listtuple+(6,7)
listtuple
listtuple::(6,7)
listtuple::((6,7))
listtuple==((6,7))
listtuple++((6,7))
(6,7)::listtuple
listtuple::(7,8)
listtuple.:+(7,8)
listtuple.+:(7,8)
listtuple.++(7,8)
(7,8)::listtuple
(7,9)::listtuple
(8,9)::listtuple
(181,19)::listtuple
var listtupevar=listtuple
(181,19)::listtupevar
(181,191)::listtupevar
(182,19)::listtupevar
listtupevar
:t listtupevar
know
reflect
Dcl          ::=  val ValDcl
Dcl          ::=  'val' ValDcl
listtupevar=(182,19)::listtupevar
listtupevar=(182,193)::listtupevar
engToDeu.getOrElse("dog","???")
engToDeu.getOrElse("bird","???");
engToDeu.getOrElse("bird","djhsdbj");
val engToDeu = Map(("dog","Hund"),("cat","katze"),("rhinoceros","Nashorn")).withDefault(x=>"???")
engToDeu("bird")
val engToDeu = Map(("dog","Hund"),("cat","katze"),("rhinoceros","Nashorn")).withDefault(x=>"DefaultVal")
engToDeu("bird")
Map((10,"ten"),(100,"one Hundered"))
Map(("a",1),("b",2))
val miniDictionary = Map(("befreit","liberated"),("baeche","brooks"),("eise","ice"),("sind","are"),("strom","river"),("und","and"),("vom","from"))
val example = "vom eise befreit sind strom und baeche"
example.split(" ")
example.split(" ").map(deuWord => miniDictionary(deuWord))
example.split(" ").map(deuWord => miniDictionary(deuWord)).mkString(" ");
val example = "vom eise befreit sind strom und schiffe"
val miniDictionary = Map(("befreit","liberated"),("baeche","brooks"),("eise","ice"),("sind","are"),("strom","river"),("und","and"),("vom","from")).withDefault(x=>"???")
example.split(" ").map(srinu => miniDictionary(srinu)).mkString(" ");
printf("when we dont have the key for the above case we will get an exception saying no key found")
val numbers = List(1,4,5,1,6,5,2,8,1,9,2,1)
numbers.groupBy(x=>x);
numbers.groupBy(x=>x)(1)
numbers.groupBy(x=>x)(2)
numbers.groupBy(x=>x)(3)
numbers.groupBy(x=>x)(5)
var map2=numbers.groupBy(x=>x)
map2(5)
map2(1)
val tagged = "in/Prep the/Det dark/Noun ,/Punc a/Det tall/Adjective man/Noun saw/Verb the/Det saw/Noun that/Pronoun he/Pronoun needed/Verb to/Prep man/Verb to/Prep cut/Verb the/Det dark/Adjective tree/Noun ./Punc";
tagged.split(" ");
tagged.split(" ").map(x=>x.split("/"))
tagged.split(" ").map(x=>(x.split("/"),x.length))
tagged.split(" ").map(x=>(x.split("/"),x.length)).map(x=>(x._2,x._1))
tagged.split(" ").map(x=>(x.split("/"),x.length)).map(x=>(x._2,x._1)).toMap
tagged.split(" ").map(x=>x.split("/"))
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1)))
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._1)
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._2)
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._2)("Prep")
val tagMap=tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._2)
tagMap("Noun")
tagMap "Noun"
tagMap("Adjective")
val groupedTagged = tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._2)
val groupedTagged = tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).groupBy(x=>x._1)
groupedTagged("saw");
groupedTagged("saw").map(x=>x._2)
groupedTagged("saw").map(x=>x(1))
printf("we got error because Inside Array we have tuples")
groupedTagged("saw").map(x=>x._2).toSet
groupedTagged("the");
groupedTagged("the").map(x=>x._2)
groupedTagged("the").map(x=>x._2).toSet
tagged
val woodchuck = "how much wood could a woodchuck chuck if a woodchuck could chuck wood ? as much wood as a woodchuck would , if a woodchuck could chuck wood ."val woodchuck = "how much wood could a woodchuck chuck if a woodchuck could chuck wood ? as much wood as a woodchuck would , if a woodchuck could chuck wood ."
val woodchuck = "how much wood could a woodchuck chuck if a woodchuck could chuck wood ? as much wood as a woodchuck would , if a woodchuck could chuck wood ."
woodchuck.split(" ").groupBy(x=>x)
tagged.split(" ").map(x=>x.split("/")).groupBy(x=>x);
woodchuck.split(" ").groupBy(x=>x)("woodchuck")
woodchuck.split(" ").groupBy(x=>x).mapValues(x=>x.length)
val counts = woodchuck.split(" ").groupBy(x=>x).mapValues(x=>x.length)
counts("woodchuck")
counts("chuck")
counts("if")
counts.keys
counts.values
for((k,v) <- counts) println( k + "->" + v)
counts
counts.keys.toList
counts.keys.toList.map(k => (counts(k),k))
counts.keys.toList.map(k => (counts(k),k)).groupBy(x=>x)
counts.keys.toList.map(k => (counts(k),k)).groupBy(x=>x._1)
counts.keys.toList.map(k => (counts(k),k)).groupBy(x=>x._1).mapValues(x=>x.map(y=> y._2))
printf("group by created Map")
printf("group by creates Map")
counts.keys.toList.map(k => (counts(k),k)).groupBy(x=>x._1).mapValues(x=>x.map(y=> y._2)).keys
val countsToWords = counts.keys.toList.map(k => (counts(k),k)).groupBy(x=>x._1).mapValues(x=>x.map(y=> y._2))
countsToWords.keys
countsToWords.keys.toList
countsToWords.keys.toList.sorted
countsToWords.keys.toList.sorted.reverse
countsToWords.keys.toList.sorted.reverse.foreach(x=> println(x + ":" + countsToWords(x)))
countsToWords(4)
countsToWords(4).sorted
countsToWords(4).sorted.mkString(" ")
countsToWords.keys.toList.sorted.reverse.foreach(x=> println(x + ":" + countsToWords(x).sorted.mkString(" "))
     | )
engToDeu.get("dog").get
engToDeu.get("dog");
engToDeu("dog")
printf("see the diff above")
engToDeu.getOrElse("bird","????")
engToDeu.get("bird").get
val wordsToTranslate = List("dog","bird","cat","armadillo");
engToDeu
wordsToTranslate
wordsToTranslate.foreach { x=> engToDeu.get(x) match {
     | case Some(y) => println(x + "->" +y)
     | case None =>
 wordsToTranslate.foreach { x=> engToDeu.get(x) match {
case Some(y) => println(x + "->" +y)
 case None =>
}
 wordsToTranslate.foreach { x=> engToDeu.get(x) match {
case Some(y) => println(x + "->" +y)
 case None => println("no val")
}
 wordsToTranslate.foreach { x=> engToDeu.get(x) match {
case Some(y) => println(x + "->" +y)
 case None => println(x+"-> no val")
}
 wordsToTranslate.foreach { x=> engToDeu(x) match {
case y => println(x + "->" +y)
 case None => println(x+"-> no val")
}
 wordsToTranslate.foreach { x=> engToDeu(x) match {
case y => println(x + "->" +y)
 case _ => println(x+"-> no val")
}
 wordsToTranslate.foreach { x=> engToDeu(x) match {
case y => println(x + "->" +y)
 case _ =>
}
val sentences = List(List("Here","is","sentence","one","."),List("The","third","sentence","is","empty","!"),List(),List("Lastly",",","we","have","a","final","sentence","."))
sentences.flatten
sentences.flatten.mkString(" ")
sentences.flatten.mkString(" ").foreach(println)
sentences.flatten.mkString(" ").foreach(print)
wordsToTranslate.map(x => engToDeu.get(x))
wordsToTranslate.map(x => engToDeu.get(x)).flatten
val miniDictionary = Map(("befreit","liberated"),("baeche","brooks"),("eise","ice"),("sind","are"),("strom","river"),("und","and"),("vom","from"))
val example = "vom eise befreit sind strom und baeche"
val example = "vom eise befreit sind strom und schiffe"
example.split(" ").map(x => miniDictionary.get(x))
example.split(" ").map(x => miniDictionary.get(x)).flatten
example.split(" ").flatMap(deuWord => miniDictionary.get(deuWord))
example.split(" ").flatMap(deuWord => miniDictionary.get(deuWord)).mkString(" ")
example.split(" ").flatMap(deuWord => miniDictionary.get(deuWord)).mkString(" ").foreach(print)
example.split(" ").flatMap(deuWord => miniDictionary.get(deuWord)).mkString(" ").foreach(println)
example.split(" ").flatMap(deuWord => miniDictionary.get(deuWord)).mkString(" ").foreach(print)
object JohnSmith {
     |   val firstName = "John"
     |   val lastName = "Smith"
     |   val age = 37
     |   val occupation = "linguist"
     |  
     |   def fullName: String = firstName + " " + lastName
     |  
     |   def greet (formal: Boolean): String = {
     |     if (formal)
     |       "Hello, my name is " + fullName + ". I'm a " + occupation + "."
     |     else
     |       "Hi, I'm " + firstName + "!"
     |   }
     |  
   object JohnSmith {
  val firstName = "John"
  val lastName = "Smith"
  val age = 37
  val occupation = "linguist"
 
  def fullName: String = firstName + " " + lastName
 
  def greet (formal: Boolean): String = {
    if (formal)
      "Hello, my name is " + fullName + ". I'm a " + occupation + "."
    else
      "Hi, I'm " + firstName + "!"
  }
 
}
JohnSmith.firstNam
JohnSmith.firstName
JohnSmith.lastName.toString.print
JohnSmith.lastName.toString
JohnSmith.lastName.mkString()
print JohnSmith.lastName
println(JohnSmith.lastName)
JohnSmith.greet(true)
println(JohnSmith.greet(true))
JohnSmith.greet(false)
println(JohnSmith.greet(false))
object JaneDoe {
  val firstName = "Jane"
  val lastName = "Doe"
  val age = 34
  val occupation = "Computer Scientist"
 
  def fullName: String = firstName + " " + lastName
 
  def greet (formal: Boolean): String = {
    if (formal)
      "Hello, my name is " + fullName + ". I'm a " + occupation + "."
    else
      "Hi, I'm " + firstName + "!"
  }
 
}
 lastName   occupation   toString
scala> JaneDoe.greet(true);
val people = List(JohnSmith,JaneDoe);
val people = JohnSmith
val people1=JaneDoe
val peopleList=List(people,people1)
peopleList(0)
peopleList(0).firstName
class Person (
  val firstName: String,
  val lastName: String,
  val age: Int,
  val occupation: String
) {
 
  def fullName: String = firstName + " " + lastName
 
  def greet (formal: Boolean): String = {
    if (formal)
      "Hello, my name is " + fullName + ". I'm a " + occupation + "."
    else
      "Hi, I'm " + firstName + "!"
  }
 
}
val johnSmith = new Person("John","Smith",37,"linguist");
johnSmith.age
val JaneDoe=new Person("jane","Doe",34,"computer Science")
val johnBrown = new person("John","Brown",28,"Mathematician")
val johnBrown = new Person("John","Brown",28,"Mathematician")
val people = List(johnSmith,janeDoe,JohnDoe,johnBrown)
val people = List(johnSmith,JaneDoe,johnBrown)
people.map(person=>person.firstName)
people.map(person=>person.age)
people.map(person=>person.age).sum
people.map(person=>person.age).sum/people
people.map(person=>person.age).sum/people.length
people.map(person=>person.age).sum/people.length.toDouble
val ageSortedPople = people.sortBy(_.age)
ageSortedPople.map(person => person.fullName + ":"+person.age)
people.groupBy(person => person.firstName)
people.groupBy(person => person.lastName)
people.groupBy(person => person.firstName)("John")
people.groupBy(person => person.firstName)("John").foreach(john => println(john.greet(true)))
object ThomYorke extends Person("Thom","Yorke",43,"musician")
ThomYorke.greet(true)
class Linguist (
  firstName: String,
  lastName: String,
  age: Int,
  val speciality: String,
  val favoriteLanguage: String
) extends Person(firstName, lastName, age, "linguist") {
 
  def workGreeting =
    "As a " + occupation + ", I am a " + speciality + " who likes to study the language " + favoriteLanguage + "."
 
}
val ram = new Linguist("ram","dat",83,"syntactician","English")
ram.greet(true)
ram.workGreeting
trait Worker {
def workGreeting: String
}
class Student(school:String,subject:String) extends Worker {
def workGreeting = "I am Studying" + subject + "at" + school
}
val anaonymousStudent = new Student("SDA School","Social")
anaonymousStudent.workGreeting
class ComputerScientist (
   firstName: String,
   lastName: String,
   age: Int,
   val speciality: String,
   favoriteProgrammingLanguage: String
 ) extends Person(firstName, lastName, age, "computer scientist") with Worker {
  
   def workGreeting =
"As a " + occupation + ", I work on " + speciality + ". Much of my code is written in                       " +  gLanguage + "."
  
}
class ComputerScientist (
   firstName: String,
   lastName: String,
   age: Int,
   val speciality: String,
   favoriteProgrammingLanguage: String
 ) extends Person(firstName, lastName, age, "computer scientist") with Worker {
  
   def workGreeting = 
"As a " + occupation + ", I work on " + speciality + ". Much of my code is written in                       " +  gLanguage + "."
  
}
class ComputerScientist (
   firstName: String,
   lastName: String,
   age: Int,
   val speciality: String,
   favoriteProgrammingLanguage: String
 ) extends Person(firstName, lastName, age, "computer scientist") with Worker {
  
   def workGreeting = 
"As a " + occupation + ", I work on " + speciality + ". Much of my code is written in " +favoriteProgrammingLanguage + "."
}
val raghuMccallum = new ComputerScientist("raghu","Mccallum",44,"Machine Learning","scala")
raghuMccallum.workGreeting
val professors = List(ram,raghuMccallum)
professors.map(prof=>prof.occupation)
object Addone {
     | def apply (x:Int) : Int = x + 1
     | }
object Addone {
def apply (x:Int) : Int = x + 1
}
Addone.apply(3)
Addone(3)
class AddN(amountToAdd: Int)
class AddN(amountToAdd: Int) {
    def apply(x:Int):Int = x + amountToAdd
    }
val adds = new AddN(3)
adds(5)
val numbers = 10 to 20 toList
val numbers =(10 to 20)
val numbers =(10 to 20).toList
val numbers = 10 to 20 toList
numbers(3)
numbers.apply(3)
val sentRaw = "The/DT index/NN of/IN the/DT 100/CD largest/JJS Nasdaq/NNP financial/JJ stocks/NNS rose/VBD modestly/RB as/IN well/RB ./."
sentRaw.split(" ")
sentRaw.split(" ").map(x=>x.split("/"))
sentRaw.split(" ").map(x=>x.split("/")
\
nkj;
var raw=sentRaw.split(" ").map(x=>x.split("/")
;
var raw=sentRaw.split(" ").map(x=>x.split("/"))
var raw=sentRaw.split(" ").map(x=>x.split("/")).flatten
var raw=sentRaw.split(" ").map(x=>x.split("/")).toTuple
var raw=sentRaw.split(" ").map(x=>x.split("/")).map(x=(x(0),x(1)))
var raw=sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1)))
raw.toList
raw.toMap
raw.toList(0)
raw.toList(1)
raw.toList(2)
raw.toList(4)
raw.toMap("The")
var rawMap=raw.toMap
rawMap.get("The")
rawMap.get("The").get
def coursePos (tag: String) = tag match {
  case "NN" | "NNS" | "NNP" | "NNPS"                       => "Noun"
  case "JJ" | "JJR" | "JJS"                                => "Adjective"
  case "VB" | "VBD" | "VBG" | "VBN" | "VBP" | "VBZ" | "MD" => "Verb"
  case "RB" | "RBR" | "RBS" | "WRB" | "EX"                 => "Adverb"
  case "PRP" | "PRP$" | "WP" | "WP$"                       => "Pronoun"
  case "DT" | "PDT" | "WDT"                                => "Article"
  case "CC"                                                => "Conjunction"
  case "IN" | "TO"                                         => "Preposition"
  case _                                                   => "Other"
}
rowMap.map(x=>get(x))
rowMap.keys
rowMap
rawMap.map(x=>get(x))
rawMap.map(x=>rawMap.get(x))
rawMap.keys
rawMap.keys.toList
rawMap.keys.toList.map(x=>(x,rawMap.get(x).get))
rawMap.keys.toList.map(x=>(x,coursePos(rawMap.get(x).get)))
sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap
sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.keys
sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.keys.toList
sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.keys.toList.map(x=>(x.coursePos(rawMap.get(x).get))
)
sentRaw.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.keys.toList.map(x=>(x,coursePos(rawMap.get(x).get)))
val adder = "We're as similar as two dissimilar things in a pod.\n\t-Blackadder"
val miniDictionary = Map(("befreit","liberated"),("baeche","brooks"),("eise","ice"),("sind","are"),("strom","river"),("und","and"),("vom","from"))
val example = "vom eise befreit sind strom und baeche"
val miniDictionary = Map(("befreit","liberated"),("baeche","brooks"),("eise","ice"),("sind","are"),("strom","river"),("und","and"),("vom","from")).withDefault(x=>"???")
example.split(" ").map(x=>miniDictionary.get(x).get).flatten
example.split(" ").map(x=>miniDictionary.get(x).get)
example.split(" ").map(x=>miniDictionary.get(x).get).foreach(print)
example.split(" ").map(x=>miniDictionary.get(x).get).foreach(println)
example.split(" ").map(x=>miniDictionary.get(x).get).mkString(" ")
example.split(" ").map(x=>miniDictionary.get(x).get).mkString(" ").foreacj(print)
example.split(" ").map(x=>miniDictionary.get(x).get).mkString(" ").foreach(print)
val tagged = "in/Prep the/Det dark/Noun ,/Punc a/Det tall/Adjective man/Noun saw/Verb the/Det saw/Noun that/Pronoun he/Pronoun needed/Verb to/Prep man/Verb to/Prep cut/Verb the/Det dark/Adjective tree/Noun ./Punc"
tagged.split(" ").map(x=>split("/"))
tagged.split(" ").map(x=>x.split("/"))
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1)))
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).flatten
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap
tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.withDefault(x=>"???")
val sentences = List(List("Here","is","sentence","one","."),List("The","third","sentence","is","empty","!"),List(),List("Lastly",",","we","have","a","final","sentence","."))val sentences = List(List("Here","is","sentence","one","."),List("The","third","sentence","is","empty","!"),List(),List("Lastly",",","we","have","a","final","sentence","."))
val sentences = List(List("Here","is","sentence","one","."),List("The","third","sentence","is","empty","!"),List(),List("Lastly",",","we","have","a","final","sentence","."))
sentences.map(x=>x.map(x=>x))
val v=tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap.withDefault(x=>"???")
sentences.map(x=>x.map(x=>"x"))
sentences.map(x=>x.map(x=>x))
sentences.map(x=>x.map(x=>v.get(x).get))
v.get("cut")
v.get("cut").get
v.get(cut)
v.get("fdf").get
val vdef=tagged.split(" ").map(x=>x.split("/")).map(x=>(x(0),x(1))).toMap
val v=vdef.withDefault(x=>"???")
v.get("fdf").get
v.get("fdf")
sentences.map(x=>x.map(x=>v.get(x)))
sentences.map(x=>x.map(x=>v.get(x) match{))
sentences.map(x=>x.map(x=>v.get(x) match{
case Some(y) => println(y)
case None => println("dunno")
}
))
sentences.map(x=>x.map(x=>v.get(x) match{
case Some(y) => y
case None => "dunno"
}
))
:history 1000
:history 2000
:save repl_his.txt
:help
sess
sess.sva
sess.save
:history 500
:help history
:h4
:h?
:h? val
:h? 1
